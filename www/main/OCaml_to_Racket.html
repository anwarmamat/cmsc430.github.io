<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2&nbsp;From OCaml to Racket</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="accessibility.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 430:<span class="mywbr"> &nbsp;</span> Design and Implementation of Programming Languages</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="Schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="Notes.html" class="tocviewselflink" data-pltdoc="x">Notes</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Midterms.html" class="tocviewlink" data-pltdoc="x">Midterms</a></td></tr><tr><td align="right"></td><td><a href="Project.html" class="tocviewlink" data-pltdoc="x">Project</a></td></tr><tr><td align="right"></td><td><a href="Software.html" class="tocviewlink" data-pltdoc="x">Software</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Notes.html" class="tocviewlink" data-pltdoc="x">Notes</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Intro.html" class="tocviewlink" data-pltdoc="x">What <span class="emph">is</span> a Compiler?</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">From OCaml to Racket</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="a86.html" class="tocviewlink" data-pltdoc="x">a86:<span class="mywbr"> &nbsp;</span> a Little Assembly Language</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Abscond.html" class="tocviewlink" data-pltdoc="x">Abscond:<span class="mywbr"> &nbsp;</span> a language of numbers</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Blackmail.html" class="tocviewlink" data-pltdoc="x">Blackmail:<span class="mywbr"> &nbsp;</span> incrementing and decrementing</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Con.html" class="tocviewlink" data-pltdoc="x">Con:<span class="mywbr"> &nbsp;</span> branching with conditionals</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="Dupe.html" class="tocviewlink" data-pltdoc="x">Dupe:<span class="mywbr"> &nbsp;</span> a duplicity of types</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Dodger.html" class="tocviewlink" data-pltdoc="x">Dodger:<span class="mywbr"> &nbsp;</span> addressing a lack of character</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Evildoer.html" class="tocviewlink" data-pltdoc="x">Evildoer:<span class="mywbr"> &nbsp;</span> change the world a couple nibbles at a time</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Extort.html" class="tocviewlink" data-pltdoc="x">Extort:<span class="mywbr"> &nbsp;</span> when errors exist</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Fraud.html" class="tocviewlink" data-pltdoc="x">Fraud:<span class="mywbr"> &nbsp;</span> local binding, variables, and binary operations</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Hustle.html" class="tocviewlink" data-pltdoc="x">Hustle:<span class="mywbr"> &nbsp;</span> heaps and lists</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Hoax.html" class="tocviewlink" data-pltdoc="x">Hoax:<span class="mywbr"> &nbsp;</span> vectors and strings</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Iniquity.html" class="tocviewlink" data-pltdoc="x">Iniquity:<span class="mywbr"> &nbsp;</span> function definitions and calls</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Jig.html" class="tocviewlink" data-pltdoc="x">Jig:<span class="mywbr"> &nbsp;</span> jumping to tail calls</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Knock.html" class="tocviewlink" data-pltdoc="x">Knock:<span class="mywbr"> &nbsp;</span> pattern matching</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Loot.html" class="tocviewlink" data-pltdoc="x">Loot:<span class="mywbr"> &nbsp;</span> lambda the ultimate</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Mug.html" class="tocviewlink" data-pltdoc="x">Mug:<span class="mywbr"> &nbsp;</span> symbols and interned string literals</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="Mountebank.html" class="tocviewlink" data-pltdoc="x">Mountebank:<span class="mywbr"> &nbsp;</span> quote and compound static data</a></td></tr><tr><td align="right">20&nbsp;</td><td><a href="Neerdowell.html" class="tocviewlink" data-pltdoc="x">Neerdowell:<span class="mywbr"> &nbsp;</span> structures</a></td></tr><tr><td align="right">21&nbsp;</td><td><a href="Outlaw.html" class="tocviewlink" data-pltdoc="x">Outlaw:<span class="mywbr"> &nbsp;</span> self-<wbr></wbr>hosting</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">From OCaml to Racket</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._.Basic_values%29" class="tocviewlink" data-pltdoc="x">Basic values</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._.Basic_operations%29" class="tocviewlink" data-pltdoc="x">Basic operations</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part._.Numbers%29" class="tocviewlink" data-pltdoc="x">Numbers</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#%28part._.Functions%29" class="tocviewlink" data-pltdoc="x">Functions</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#%28part._ocaml._.Definitions%29" class="tocviewlink" data-pltdoc="x">Definitions</a></td></tr><tr><td align="right">2.6&nbsp;</td><td><a href="#%28part._.Lists%29" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">2.7&nbsp;</td><td><a href="#%28part._.Pattern_matching%29" class="tocviewlink" data-pltdoc="x">Pattern matching</a></td></tr><tr><td align="right">2.8&nbsp;</td><td><a href="#%28part._.Structures%29" class="tocviewlink" data-pltdoc="x">Structures</a></td></tr><tr><td align="right">2.9&nbsp;</td><td><a href="#%28part._.Symbols%29" class="tocviewlink" data-pltdoc="x">Symbols</a></td></tr><tr><td align="right">2.10&nbsp;</td><td><a href="#%28part._.Quote%29" class="tocviewlink" data-pltdoc="x">Quote</a></td></tr><tr><td align="right">2.11&nbsp;</td><td><a href="#%28part._.Testing__modules__submodules%29" class="tocviewlink" data-pltdoc="x">Testing, modules, submodules</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Basic_values%29" class="tocsubseclink" data-pltdoc="x">Basic values</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Basic_operations%29" class="tocsubseclink" data-pltdoc="x">Basic operations</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Numbers%29" class="tocsubseclink" data-pltdoc="x">Numbers</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._ocaml._.Definitions%29" class="tocsubseclink" data-pltdoc="x">Definitions</a></td></tr><tr><td><span class="tocsublinknumber">2.6<tt>&nbsp;</tt></span><a href="#%28part._.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists</a></td></tr><tr><td><span class="tocsublinknumber">2.7<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_matching%29" class="tocsubseclink" data-pltdoc="x">Pattern matching</a></td></tr><tr><td><span class="tocsublinknumber">2.8<tt>&nbsp;</tt></span><a href="#%28part._.Structures%29" class="tocsubseclink" data-pltdoc="x">Structures</a></td></tr><tr><td><span class="tocsublinknumber">2.9<tt>&nbsp;</tt></span><a href="#%28part._.Symbols%29" class="tocsubseclink" data-pltdoc="x">Symbols</a></td></tr><tr><td><span class="tocsublinknumber">2.10<tt>&nbsp;</tt></span><a href="#%28part._.Quote%29" class="tocsubseclink" data-pltdoc="x">Quote</a></td></tr><tr><td><span class="tocsublinknumber">2.11<tt>&nbsp;</tt></span><a href="#%28part._.Testing__modules__submodules%29" class="tocsubseclink" data-pltdoc="x">Testing, modules, submodules</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.15</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Intro.html" title="backward to &quot;1 What is a Compiler?&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="a86.html" title="forward to &quot;3 a86: a Little Assembly Language&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h4 class="heading">2<tt>&nbsp;</tt><a name="(part._.O.Caml._to._.Racket)"></a>From OCaml to Racket<span class="button-group"><a href="#(part._.O.Caml._to._.Racket)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><span class="emph">Racket = OCaml with uniform syntax and no types (for now)</span></p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Basic_values%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Basic values</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Basic_operations%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Basic operations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Numbers%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>Numbers</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Functions%29" class="toclink" data-pltdoc="x">2.4<span class="hspace">&nbsp;</span>Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._ocaml._.Definitions%29" class="toclink" data-pltdoc="x">2.5<span class="hspace">&nbsp;</span>Definitions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists%29" class="toclink" data-pltdoc="x">2.6<span class="hspace">&nbsp;</span>Lists</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pattern_matching%29" class="toclink" data-pltdoc="x">2.7<span class="hspace">&nbsp;</span>Pattern matching</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Structures%29" class="toclink" data-pltdoc="x">2.8<span class="hspace">&nbsp;</span>Structures</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Symbols%29" class="toclink" data-pltdoc="x">2.9<span class="hspace">&nbsp;</span>Symbols</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Quote%29" class="toclink" data-pltdoc="x">2.10<span class="hspace">&nbsp;</span>Quote</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Testing__modules__submodules%29" class="toclink" data-pltdoc="x">2.11<span class="hspace">&nbsp;</span>Testing, modules, submodules</a></p></td></tr></table><h5 class="heading">2.1<tt>&nbsp;</tt><a name="(part._.Basic_values)"></a>Basic values<span class="button-group"><a href="#(part._.Basic_values)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>Let&rsquo;s start by looking at something you know: OCaml.  In OCaml,
expressions can include literals for numbers, strings, booleans.  Here
we are using the OCaml read-eval-print-loop (REPL) to type in examples
and evaluate their results:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">8</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># <span class="st">&quot;ocaml&quot;</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;ocaml&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">true</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">false</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
</p></blockquote></blockquote><p>When the REPL is given an expression, it is evaluated to a value.  In
the case of OCaml, it prints both the value and its type.  OCaml is
able to determine the type of the value <span class="emph">before</span> evaluating the
expression, thanks to its static type system.</p><p>Note that the <span class="stt">;;</span> is not part of the expression syntax, but is a
terminator token, signalling to the REPL that the expression is
complete and ready to be evaluated.</p><p>The Racket REPL operates similarly, but doesn&rsquo;t require a terminator:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktVal">8</span></td></tr><tr><td><p><span class="RktRes">8</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktVal">"racket"</span></td></tr><tr><td><p><span class="RktRes">"racket"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktVal">#t</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktVal">#f</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote></blockquote></blockquote><p>OCaml prints out the type of each expression, in addition to its
value, while Racket only prints the value.  The notation for booleans
is slightly different, but both languages agree on numbers, strings,
and booleans.  OCaml uses a <span class="stt">#</span> prompt, while Racket uses <span class="stt">&gt;</span>,
but these differences are immaterial.  The languages are essentially
the same so far.</p><p>Racket doesn&rsquo;t print the type because it does not have a static type
system like OCaml&rsquo;s and it has no way of predicting the type of value
an expression will produce before it&rsquo;s evaluated.</p><h5 class="heading">2.2<tt>&nbsp;</tt><a name="(part._.Basic_operations)"></a>Basic operations<span class="button-group"><a href="#(part._.Basic_operations)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>OCaml uses an infix notation for writing operations.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">1</span> + <span class="dv">2</span> * <span class="dv">2</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">5</span></span></code></pre></div>
</p></blockquote></blockquote><p>The order of operations follows the usual mathematical precendence
rules (which you must memorize), or you can use parentheses to indicate grouping:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">1</span> + (<span class="dv">2</span> * <span class="dv">2</span>);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">5</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># (<span class="dv">1</span> + <span class="dv">2</span>) * <span class="dv">2</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span></code></pre></div>
</p></blockquote></blockquote><p>Extraneous parenthesis are fine:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># (((<span class="dv">1</span>))) + ((<span class="dv">2</span> * <span class="dv">2</span>));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">5</span></span></code></pre></div>
</p></blockquote></blockquote><p>Compared to many languages you may know, including OCaml, Racket
employs a uniform, minimalistic concrete syntax based on the concept
of parenthesized, prefix notation.</p><p>In this notation, parentheses play a much more central role.  They are
not optional and they signal the form of the expression.</p><p>Languages, like people, descend from their ancestors and inherit some
of their properties.  In the case of notation, Racket inherits the
Lisp (and Scheme) notation for programs.  It takes a bit of getting
used to, but once aclimated, the notation should feel lightweight and
consistent; there is very little to memorize when it comes to syntax.</p><p>So in Racket, we would write:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">6</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Note that there are no precendence rules for addition and
multiplication: the form of the expression makes it unambiguous.</p><p>Parenthesis indicate function applications, so adding extraneous
parens means something different than in OCaml:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">application: not a procedure;</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr">expected a procedure that can be applied to arguments</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 1</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Here the parens are indicating a function application.  The
&ldquo;function&rdquo; is the first subexpression within the parens,
i.e. <span class="RktVal">1</span>.  Of course, <span class="RktVal">1</span> isn&rsquo;t a function and can&rsquo;t be
applied, hence the error.</p><h5 class="heading">2.3<tt>&nbsp;</tt><a name="(part._.Numbers)"></a>Numbers<span class="button-group"><a href="#(part._.Numbers)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>Integers in OCaml and Racket look pretty similar, but the two
languages have differing approaches to numbers overall.  In OCaml, the
<span class="stt">int</span> type can represent only fixed bit-width integers.  Hence
there is a maximal (and minimal) integer.  The variables <span class="stt">max_int</span>
and <span class="stt">min_int</span> are bound to these values, respectively:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dt">max_int</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">4611686018427387903</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># <span class="dt">min_int</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">-4611686018427387904</span></span></code></pre></div>
</p></blockquote></blockquote><p>What happens when you do something like add 1 to <span class="stt">max_int</span>?  Mess
around and find out.</p><p>In Racket, integers behave like the integers you learned about in math
class.  There&rsquo;s no largest or smallest one:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4611686018427387903</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">4611686018427387904</span></p></td></tr></table></blockquote></blockquote></blockquote><p>In principle, you can represent arbitrarily large (or small) integers.
In practice, you are bounded by the amount of memory available that
can be used to represent those integers.</p><p>Another difference is that in OCaml, integers are disjoint from
floating point numbers.  They have different literal syntaxes,
different types, and different operations.  If you want to add a
floating point number and an integer together, you&rsquo;ll have to
explicitly convert one of them.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">1</span> +. <span class="fl">3.14</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Error: This expression has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="dt">float</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># (<span class="dt">float_of_int</span> <span class="dv">1</span>) +. <span class="fl">3.14</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">4.14000000000000057</span></span></code></pre></div>
</p></blockquote></blockquote><p>In Racket, operations work on different kinds of numbers and can be
used without conversions:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">3.14</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">4.140000000000001</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Moreover, Racket has certain kinds of numbers that are not supported
(without using libraries) in OCaml.  For example, you can write
<span class="RktVal">2/3</span> to mean the rational number two-thirds in Racket:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktVal">2/3</span></td></tr><tr><td><p><span class="RktRes">2/3</span></p></td></tr></table></blockquote></blockquote></blockquote><p>It&rsquo;s worth noting that while this may look like division, it&rsquo;s not: we
are writing the literal number <span class="RktVal">2/3</span>.  The division operator,
like every other operation, would have to be written using prefix
notation with parentheses:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2F%29%29" class="RktValLink" data-pltdoc="x">/</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2/3</span></p></td></tr></table></blockquote></blockquote></blockquote><p>But notice that division produces exact rational results, not a
floating point approximation as in OCaml:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">2</span>. /. <span class="dv">3</span>.;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">0.66666666666666663</span></span></code></pre></div>
</p></blockquote></blockquote><p>It&rsquo;s also possible to use complex numbers in Racket.  The
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._sqrt%29%29" class="RktValLink" data-pltdoc="x">sqrt</a></span> operation computes the square root of its argument:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._sqrt%29%29" class="RktValLink" data-pltdoc="x">sqrt</a></span><span class="hspace">&nbsp;</span><span class="RktVal">16</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">4</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._sqrt%29%29" class="RktValLink" data-pltdoc="x">sqrt</a></span><span class="hspace">&nbsp;</span><span class="RktVal">25</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr></table></blockquote></blockquote></blockquote><p>But when given a negative number, it computes a complex result:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._sqrt%29%29" class="RktValLink" data-pltdoc="x">sqrt</a></span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-1</span></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">0+1i</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._sqrt%29%29" class="RktValLink" data-pltdoc="x">sqrt</a></span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-1</span>00</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">0+10i</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Mostly we will be sticking to using integers and will not taking
advantage of the advanced numeric system of Racket, but it&rsquo;s worth
knowing it&rsquo;s there.</p><h5 class="heading">2.4<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions<span class="button-group"><a href="#(part._.Functions)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>OCaml also has a notation for writing functions:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x y -&gt; x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>This make an anonymous function that consumes two integers and
produces their sum.</p><p>To apply it, we can write it justapoxed with arguments:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># (<span class="kw">fun</span> x y -&gt; x + y) <span class="dv">3</span> <span class="dv">4</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">7</span></span></code></pre></div>
</p></blockquote></blockquote><p>Note that in OCaml, every function is a function of exactly one
argument.  Therefore <span class="stt">fun x y -&gt; x + y</span> is actuallty shorthand for
<span class="stt">fun x -&gt; fun y -&gt; x + y</span>.</p><p>Applying such a function to fewer than 2 arguments will do a
<span class="emph">partial</span> function application, which will produce a function
that take the remaining arguments:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># (<span class="kw">fun</span> x y -&gt; x + y) <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>To encode functions that must be given two arguments, a tuple can be
used:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> (x, y) -&gt; x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>To apply such a function, it must be given a pair of integers:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># (<span class="kw">fun</span> (x, y) -&gt; x + y) (<span class="dv">3</span>, <span class="dv">4</span>);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">7</span></span></code></pre></div>
</p></blockquote></blockquote><p>The use of <span class="stt">(x, y)</span> here in the function parameters is actually a
<span class="emph">pattern</span>.  This can be understood as shorthand for:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (x, y) -&gt; x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>So even this function is actually taking a single argument (which must
be a pair of numbers).</p><p>Racket has a similar notation for writing functions:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#&lt;procedure&gt;</span></p></td></tr></table></blockquote></blockquote></blockquote><p>You can also write this without the fancy <span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span> by
spelling it <span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#&lt;procedure&gt;</span></p></td></tr></table></blockquote></blockquote></blockquote><p>(In DrRacket, to insert a &ldquo;&#955;&rdquo; press Cmd+\.)</p><p>To apply it, it must be written in parens, juxtaposed with arguments:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">7</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Functions in Racket do not always consume a single argument.  They can
consume 0, 1, or more arguments.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#&lt;procedure&gt;</span></p></td></tr></table></blockquote></blockquote></blockquote><p>This is not a shorthand for the function above it; rather it is a function that expects two arguments:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">7</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Applying a function to the wrong number of arguments will result in an
error (and not perform partial function application):</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">arity mismatch;</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr">the expected number of arguments does not match the given</span></p></td></tr><tr><td><p><span class="RktErr">number</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: 2</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: 1</span></p></td></tr></table></blockquote></blockquote></blockquote><h5 class="heading">2.5<tt>&nbsp;</tt><a name="(part._ocaml._.Definitions)"></a>Definitions<span class="button-group"><a href="#(part._ocaml._.Definitions)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>At the top-level in OCaml, variables can be defined with <span class="stt">let</span> and
<span class="stt">let rec</span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> y = <span class="dv">4</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">4</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># x + y;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">7</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> fact = <span class="kw">fun</span> n -&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    | n -&gt; n * (fact (n - <span class="dv">1</span>));;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># fact <span class="dv">5</span>;;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span></code></pre></div>
</p></blockquote></blockquote><p>In Racket, variables are defined with the <span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span> form:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">7</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">fact</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">120</span></p></td></tr></table></blockquote></blockquote></blockquote><p>(Note that the use of square brackets here is stylistic:
from Racket&rsquo;s point of view as long as &ldquo;parentheses&rdquo; (e.g.
<span class="stt">({[</span>) match, any kind is acceptable.)</p><p>In OCaml, function definitions can be written as:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> fact n =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | n -&gt; n * (fact (n - <span class="dv">1</span>));;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>This is just a shorthand for the definition written above in terms of
<span class="stt">fun</span>.</p><p>Similarly in Racket, function definitions can be written as:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></blockquote></blockquote><p>which is shorthand for the definition above using <span class="RktSym"><a href="http://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span>.</p><p>Notice both OCaml and Racket have pattern matching forms, which are
quite useful for writing function in terms of a number of "cases."
More on this in a minute.</p><h5 class="heading">2.6<tt>&nbsp;</tt><a name="(part._.Lists)"></a>Lists<span class="button-group"><a href="#(part._.Lists)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>OCaml has a built-in list datatype.  The empty list is written <span class="stt">[]</span>
and <span class="stt">::</span> is an operation for &ldquo;consing&rdquo; an element on to a list.
So to build a list with three integer elements, 1, 2, and 3, you&rsquo;d write:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="dv">1</span> :: <span class="dv">2</span> :: <span class="dv">3</span> :: [];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span></code></pre></div>
</p></blockquote></blockquote><p>The notation <span class="stt">[1; 2; 3]</span> is just a shorthand for the above.</p><p><div class="SIntrapara">Racket has a built-in list datatype.  The empty list is written <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span>
and <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> is an operation for consing an element on to a list.
To build the same list, you&rsquo;d write:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(1<span class="stt"> </span>2<span class="stt"> </span>3)</span></p></td></tr></table></blockquote></blockquote></blockquote></div></p><p>The notation <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span> is shorthand for the above.</p><p>There is a slight difference here.  For one, OCaml lists must be <span class="emph">homogeneous</span>.  You can have a list
of strings or a list of numbers, but you can&rsquo;t have a list of strings <span class="emph">and</span> numbers.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># [<span class="st">&quot;a&quot;</span>; <span class="dv">3</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Error: This expression has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="dt">string</span></span></code></pre></div>
</p></blockquote></blockquote><p>In Racket, there is no such restriction:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("a"<span class="stt"> </span>3)</span></p></td></tr></table></blockquote></blockquote></blockquote><p>Also, in Racket, <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> plays the role of both tupling (making
pairs) and making lists (making a pair of an element and another list).</p><p>So in OCaml, you could make a pair <span class="stt">("a", 3)</span>.  In Racket, you&rsquo;d
write <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">"a"</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span>.  Note this is a pair and not a proper
list.  In OCaml, tuples and lists are disjoint things.  In Racket,
lists and tuples (pairs) are made out of the same stuff.</p><p>This can be confusing the first time you encounter it, so
let&rsquo;s go over it a bit more.</p><p>In Racket (or any Lisp), <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span> plays the role of
both the pair constructor and the list constructor.
Non-empty lists are a subset of pairs: they are pairs whose
second component is a list (either the empty list or another
pair whose second component is a list, etc.).</p><p>You can make pairs out of any kind of element and you can
make lists out of any kind of elements.</p><p>The functions <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span> and <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span> operate on
non-empty <span class="emph">lists</span>, producing the first element of the
list and the tail of the list, respectively.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">3</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(4)</span></p></td></tr></table></blockquote></blockquote></blockquote><p>These function will produce errors if given something that
is a pair but not a list:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">first: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: (and/c list? (not/c empty?))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: '(3 . 4)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">rest: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: (and/c list? (not/c empty?))</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: '(3 . 4)</span></p></td></tr></table></blockquote></blockquote></blockquote><p>On the other hand, the functions <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span> and
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span> access the left and right components of a pair
(the names are admittedly awful and an artifact of Lisp
history):</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">3</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">4</span></p></td></tr></table></blockquote></blockquote></blockquote><p>When given pairs that are also lists, they behave just like
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._first%29%29" class="RktValLink" data-pltdoc="x">first</a></span> and <span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._car%29%29" class="RktValLink" data-pltdoc="x">car</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">3</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cdr%29%29" class="RktValLink" data-pltdoc="x">cdr</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(4)</span></p></td></tr></table></blockquote></blockquote></blockquote><h5 class="heading">2.7<tt>&nbsp;</tt><a name="(part._.Pattern_matching)"></a>Pattern matching<span class="button-group"><a href="#(part._.Pattern_matching)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>OCaml has a very nice pattern matching mechanism for letting you
express case analysis and decomposition in a concise way.</p><p>Each pattern maching expression has a sub-expression that produce a
value to be matched against and a number of clauses.  Each clause has
a pattern and an expression.  The pattern potentially consists of data
constructors, variables, and literals.  If the value matches the first
pattern, meaning the value and the template match up on constructors
and literals, then the variables are bound to the correspond parts of
the value, and the right-hand side expression is evaluated.  If the
value doesn&rsquo;t match, the next pattern is tried, and so on.  It&rsquo;s an
error if none of the patterns match.</p><p>So for example, we can write a function that recognize even digits as:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> even_digit n =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="kw">true</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">2</span> -&gt; <span class="kw">true</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">4</span> -&gt; <span class="kw">true</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">6</span> -&gt; <span class="kw">true</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">8</span> -&gt; <span class="kw">true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> even_digit : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>The patterns here, save the last one, are just integer literals.  If
<span class="stt">n</span> is the same as any of these integers, the value <span class="stt">true</span> is
produced.  The last case uses a "wildcard," which matches anything and
produces <span class="stt">false</span>.</p><p>Here&rsquo;s an example that matches a tuple, binding each part of the tuple
to a name and then using those names to construct a different tuple:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> swap p =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> p <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x, y) -&gt; (y, x);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> swap : &#39;a * &#39;b -&gt; &#39;b * &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</p></blockquote></blockquote><p>Here the pattern uses a data constructor (the tuple constructor).  It
matches any value that is made with the same constructor.</p><p>Here is a recursive function for computing the sum of a list of
numbers, defined with pattern matching:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> sum xs =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> xs <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | x :: xs -&gt; x + (sum xs);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># sum [<span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">15</span></span></code></pre></div>
</p></blockquote></blockquote><p>We can do the same in Racket:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">even-digit</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">6</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">8</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">swap</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">p</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktSym">xs</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">15</span></p></td></tr></table></blockquote></blockquote></blockquote><h5 class="heading">2.8<tt>&nbsp;</tt><a name="(part._.Structures)"></a>Structures<span class="button-group"><a href="#(part._.Structures)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>OCaml has the ability to declare new datatypes using records and
variants.  For example, we can define type for binary trees of
integers:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> bt =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   | Leaf</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Node <span class="kw">of</span> <span class="dt">int</span> * bt * bt;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> bt = Leaf | Node <span class="kw">of</span> <span class="dt">int</span> * bt * bt</span></code></pre></div>
</p></blockquote></blockquote><p>This declares a new type, named <span class="stt">bt</span>. There are two
<span class="emph">variants</span> of the <span class="stt">bt</span> type, each with their own
constructor: <span class="stt">Leaf</span> and <span class="stt">Node</span>. The <span class="stt">Leaf</span>
constructor takes no arguments, so just writing <span class="stt">Leaf</span>
creates a (empty) binary tree:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># Leaf;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : bt = Leaf</span></code></pre></div>
</p></blockquote></blockquote><p>The <span class="stt">Node</span> constructor takes three arguments: an integer
and two binary trees. Applying the constructor to a tuple of
three things, makes a (non-empty) binary tree:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># Node (<span class="dv">3</span>, Leaf, Leaf);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : bt = Node (<span class="dv">3</span>, Leaf, Leaf)</span></code></pre></div>
</p></blockquote></blockquote><p>Binary trees are an example of a <span class="emph">recursive</span> datatype,
since one of the variants contains binary trees. This means
we can build up arbitrarily large binary trees by nesting
nodes within nodes:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># Node (<span class="dv">3</span>, Node (<span class="dv">4</span>, Leaf, Leaf), Node (<span class="dv">7</span>, Leaf, Leaf));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : bt = Node (<span class="dv">3</span>, Node (<span class="dv">4</span>, Leaf, Leaf), Node (<span class="dv">7</span>, Leaf, Leaf))</span></code></pre></div>
</p></blockquote></blockquote><p>Pattern matching is used to do case analysis and deconstruct
values. So for example, a function that determines if a
binary tree is empty can be written as:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> bt_is_empty bt =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> bt <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; <span class="kw">true</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | Node _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> bt_is_empty : bt -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># bt_is_empty Leaf;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># bt_is_empty (Node (<span class="dv">3</span>, Leaf, Leaf));;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
</p></blockquote></blockquote><p>The patterns use the constructor names to discriminate on
which constructor was used for a given binary tree. The use
of the wildcard here is just saying it doesn&rsquo;t matter what&rsquo;s
inside a node; if you&rsquo;re a node, you&rsquo;re not empty.</p><p>Recursive functions work similarly, but use variables inside
patterns to bind names to the binary trees contained inside
a node:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> bt_height bt =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> bt <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | Node (_, left, right) -&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span> + <span class="dt">max</span> (bt_height left) (bt_height right);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> bt_height : bt -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># bt_height Leaf;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># bt_height (Node (<span class="dv">4</span>, Node (<span class="dv">2</span>, Leaf, Leaf), Leaf));;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span></code></pre></div>
</p></blockquote></blockquote><p>We do something very similar in Racket using <span class="emph">structures</span>.
A structure type is like a (single) variant of
a data type in OCaml: it&rsquo;s a way of combining several things
into one new kind of value.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">leaf</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">i</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote><p>This declares two new kinds of values: leaf structures and
node structures. For each, we get a constructor, which is a
function named after the structure type. The <span class="RktSym">leaf</span>
constructor takes no arguments. The <span class="RktSym">node</span>
constructor takes 3 arguments.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(leaf)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(node <span class="stt"> </span>5<span class="stt"> </span>(leaf)<span class="stt"> </span>(leaf))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(node <span class="stt"> </span>3<span class="stt"> </span>(node <span class="stt"> </span>2<span class="stt"> </span>(leaf)<span class="stt"> </span>(leaf))<span class="stt"> </span>(leaf))</span></p></td></tr></table></blockquote></blockquote></blockquote><p>With these structure definitions in place, we can represent binary
trees of integers just as in OCaml, and functions that process binary
trees look very similar:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._max%29%29" class="RktValLink" data-pltdoc="x">max</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">0</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2</span></p></td></tr></table></blockquote></blockquote></blockquote><p>One thing to note here is that in OCaml, the <span class="stt">Node</span> and <span class="stt">Leaf</span>
constructors are part of the <span class="stt">bt</span> type.  You can&rsquo;t construct a node
that doesn&rsquo;t conform to the <span class="stt">bt</span> type definition and you can&rsquo;t
re-use these constructors in the definition of some other type.</p><p>This isn&rsquo;t the case in Racket.  Structures, like pairs and lists, can
contain any kind of value.  So while it doesn&rsquo;t conform to our idea of
what a binary tree is: <span class="RktPn">(</span><span class="RktSym">node</span><span class="stt"> </span><span class="RktVal">#t</span><span class="stt"> </span><span class="RktVal">"fred"</span><span class="stt"> </span><span class="RktVal">9</span><span class="RktPn">)</span> is a value in
Racket.</p><h5 class="heading">2.9<tt>&nbsp;</tt><a name="(part._.Symbols)"></a>Symbols<span class="button-group"><a href="#(part._.Symbols)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>One of the built-in datatypes we will use often in Racket is
that of a <span class="emph">symbol</span>. A symbol is just an atomic peice of
data. A symbol is written using the <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> notation
<span class="RktPn">(</span><span class="RktSym">quote</span><span class="stt"> </span><span class="RktVal">symbol-name</span><span class="RktPn">)</span>, which is abbreviated
<span class="RktVal">'</span><span class="RktVal">symbol-name</span>. What&rsquo;s allowable as a symbol name
follows the same rules as what&rsquo;s allowable as a Racket
identifier.</p><p>Symbols don&rsquo;t have a whole lot of operations. The main thing
you do with symbols is tell them apart from eachother:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">wilma</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote></blockquote></blockquote><p>It is possible to convert between symbols and strings:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol-~3estring%29%29" class="RktValLink" data-pltdoc="x">symbol-&gt;string</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"fred"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._string-~3esymbol%29%29" class="RktValLink" data-pltdoc="x">string-&gt;symbol</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"fred"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'fred</span></p></td></tr></table></blockquote></blockquote></blockquote><p>There&rsquo;s also a convient function that produces a symbol that is guaranteed
to have not been used so far each time you call it:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._gensym%29%29" class="RktValLink" data-pltdoc="x">gensym</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'g55895</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._gensym%29%29" class="RktValLink" data-pltdoc="x">gensym</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'g55896</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._gensym%29%29" class="RktValLink" data-pltdoc="x">gensym</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'g55897</span></p></td></tr></table></blockquote></blockquote></blockquote><p>You can use pattern matching to match symbols:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">flintstone?</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">wilma</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">pebbles</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">flintstone?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">fred</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">flintstone?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">barney</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote></blockquote></blockquote><p>There&rsquo;s really not a precise analog to symbols in OCaml.
(There&rsquo;s something called a polymorphic variant, which plays
a similar role to symbols in OCaml, but it wasn&rsquo;t covered in
CMSC 330.)</p><h5 class="heading">2.10<tt>&nbsp;</tt><a name="(part._.Quote)"></a>Quote<span class="button-group"><a href="#(part._.Quote)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>One of the distinguishing features of languages in the Lisp family
(such as Scheme and Racket) is the <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> form.</p><p>The &ldquo;tick&rdquo; character <span class="RktVal">'</span><span class="RktVal">d</span> is used as a shorthand for
<span class="RktPn">(</span><span class="RktSym">quote</span><span class="stt"> </span><span class="RktVal">d</span><span class="RktPn">)</span>.</p><p>You&rsquo;ve already seen it show up with symbols: <span class="RktVal">'</span><span class="RktVal">x</span> is the symbol
<span class="stt">x</span>.  It also shows up in the notation for the empty list:
<span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span>.</p><p>But you can also write <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> around non-empty lists like
<span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">x</span><span class="stt"> </span><span class="RktVal">y</span><span class="stt"> </span><span class="RktVal">z</span><span class="RktVal">)</span>.  This makes a list of symbols.  It is equivalent to
saying <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">x</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">y</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">z</span><span class="RktPn">)</span>.</p><p>In fact, you can nest lists within the quoted list: <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">x</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktVal">y</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">q</span><span class="stt"> </span><span class="RktVal">r</span><span class="RktVal">)</span><span class="RktVal">)</span>.  This is equivalent to <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">y</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">q</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">r</span><span class="RktPn">)</span><span class="RktPn">)</span>.</p><p><div class="SIntrapara">Here&rsquo;s another: <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span>.  This is equivalent to
</div><div class="SIntrapara"><blockquote class="SCentered"><p><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><p>So, anything you can write with quoted lists, you can write without
quoted lists by pushing the quote inward until reaching a symbol or an
empty set of parenthesis.</p><p>You can also put strings, booleans, and numbers inside of a
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>.  As you push the quote inward, it simply disappears
when reaching a string, boolean or number.  So <span class="RktVal">'</span><span class="RktVal">5</span> is just
<span class="RktVal">5</span>.  Likewise <span class="RktVal">'</span><span class="RktVal">#t</span> is <span class="RktVal">#t</span> and <span class="RktVal">'</span><span class="RktVal">"Fred"</span>
is <span class="RktVal">"Fred"</span>.</p><p>You can also write pairs with <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>, which uses the <span class="stt">.</span>
notation for separating the left and right part of the pair.  For
example, <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">. </span><span class="RktVal">2</span><span class="RktVal">)</span> is equivalent to <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span>.  If
you write something like <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">. </span><span class="RktVal">4</span><span class="RktVal">)</span>, what you are in effect
saying is <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="stt"> </span><span class="RktVal">3</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>, an improper list that
ends in <span class="RktVal">4</span>.</p><p>In essence, <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> is a shorthand for conveniently
constructing data and is a very concise notation for writing down
ad-hoc data.  It serves much the same purpose as formats like JSON and
XML, except there&rsquo;s even less noise.</p><p>To summarize, with <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span>, you can construct</p><ul><li><p>strings</p></li><li><p>booleans</p></li><li><p>numbers</p></li><li><p>symbols</p></li><li><p>and... pairs (or lists) of those things (including this one)</p></li></ul><p>The kind of things you can construct with the <span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> form are
often called <span style="font-weight: bold">s-expressions</span>, short for <span style="font-weight: bold">symbolic
expressions</span>.</p><p>The reason for this name is because anything you can write
down as an expression, you can write down inside a
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29" class="RktStxLink" data-pltdoc="x">quote</a></span> to obtain <span class="emph">a data representation</span> of
that expression. You can render an expression as a symbolic
representation of itself.</p><p>For example, <span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span> is an expression.  When run, it applies
the <span class="emph">function</span> bound to the variable <span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span> to the arguments
<span class="RktVal">1</span> and <span class="RktVal">2</span> and produces <span class="RktVal">3</span>.  On the other hand:
<span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">+</span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktVal">)</span> constructs a peice of data, namely, a list of three
elements.  The first element is the <span class="emph">symbol</span> <span class="stt">+</span>, the second
element is <span class="RktVal">2</span>, the third element is <span class="RktVal">3</span>.</p><p>We will be using (subsets of) s-expressions extensively as our data
representation of AST and IR expressions, so it&rsquo;s important to gain a
level of fluency with them now.</p><h5 class="heading">2.11<tt>&nbsp;</tt><a name="(part._.Testing__modules__submodules)"></a>Testing, modules, submodules<span class="button-group"><a href="#(part._.Testing__modules__submodules)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>We will take testing seriously in this class.  Primarily this will
take the form of unit tests, for which we will use the
<a href="http://docs.racket-lang.org/rackunit/api.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">rackunit</span></a> library.  To use the library, you must
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span> it.</p><p>Here is a simple example:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2A%29%29" class="RktValLink" data-pltdoc="x">*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">7</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktErr">--------------------</span></p></td></tr><tr><td><p><span class="RktErr">FAILURE</span></p></td></tr><tr><td><p><span class="RktErr">name: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">check-equal?</span></p></td></tr><tr><td><p><span class="RktErr">location: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">eval:63:0</span></p></td></tr><tr><td><p><span class="RktErr">actual: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">6</span></p></td></tr><tr><td><p><span class="RktErr">expected: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">7</span></p></td></tr><tr><td><p><span class="RktErr">--------------------</span></p></td></tr></table></td></tr></table></blockquote></blockquote></blockquote><p>The <span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span> function takes two arguments (and an
optional third for a message to display should the test fail) and
checks that the first argument produces something that is
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span> to the expected outcome given as the second argument.</p><p>There are many other forms of checks and utilities for building up
larger test suites, but <span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span> will get us a long way.</p><p>As a matter of coding style, we will place tests nearby the function
they are testing and locate them within their own <span style="font-weight: bold">module</span>.
Let&rsquo;s talk about modules for a minute.</p><p>In Racket, a module is the basic unit of code organization.  Every
file is a module whose name is derived from the filename, but you can
also write modules without saving them in a file.  For example:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28quote._~23~25kernel%29._module%29%29" class="RktStxLink" data-pltdoc="x">module</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span><span class="hspace">&nbsp;</span><span class="RktSym">racket</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29" class="RktStxLink" data-pltdoc="x">provide</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._all-defined-out%29%29" class="RktStxLink" data-pltdoc="x">all-defined-out</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">leaf</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:prefab</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:prefab</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._max%29%29" class="RktValLink" data-pltdoc="x">max</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></blockquote></blockquote><p>This declares a module named <span class="RktSym">bt</span>.  It provides a single value
named <span class="RktSym">bt-height</span>.</p><p>We can require the module from the REPL to gain access to the modules
provided values:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">bt</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">0</span></p></td></tr></table></blockquote></blockquote></blockquote><p>We could have also used the <span class="stt">#lang racket</span> shorthand for
<span class="stt">(module bt racket ...)</span> and saved this in a file called
<span class="stt">bt.rkt</span>.  To import from a file in the current directory, you&rsquo;d
write <span class="stt">(require "bt.rkt")</span>.  But this doesn&rsquo;t work well in REPL.</p><p>For the most part we will organize our programs into single module
files using the <span class="stt">#lang racket</span> shorthand.  But we will place tests
within a &ldquo;sub&rdquo;-module, i.e. a module nested inside of the module
that contains the code it tests.  We will use a special form called
<span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span> which declares a submodule that has access to the
enclosing module.  Moreover, repeated uses of <span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span> will
add content to the submodule.  By convention, we will name the testing
submodule <span class="RktSym">test</span>.</p><p>So here&rsquo;s a second version of the <span class="RktSym">bt</span> module with unit tests
included (and more code).  Note the use of <span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._all-defined-out%29%29" class="RktStxLink" data-pltdoc="x">all-defined-out</a></span> to
provide everything:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28quote._~23~25kernel%29._module%29%29" class="RktStxLink" data-pltdoc="x">module</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt2</span><span class="hspace">&nbsp;</span><span class="RktSym">racket</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">provides everything defined in module</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29" class="RktStxLink" data-pltdoc="x">provide</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._all-defined-out%29%29" class="RktStxLink" data-pltdoc="x">all-defined-out</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rackunit</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">leaf</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:prefab</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:prefab</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-empty?</span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-empty?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-empty?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">7</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">bt</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._max%29%29" class="RktValLink" data-pltdoc="x">max</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">intentionally wrong test:</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bt-height</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">node</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr></table></blockquote></blockquote></blockquote><p>Requiring this module with make <span class="RktSym">bt-height</span>, but <span class="emph">it will not run the tests</span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">bt2</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote><p>Running the tests only happens when the <span class="RktSym">test</span> submodule is required:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">Racket REPL</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29" class="RktStxLink" data-pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="http://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._submod%29%29" class="RktStxLink" data-pltdoc="x">submod</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">bt2</span><span class="hspace">&nbsp;</span><span class="RktSym">test</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktErr">--------------------</span></p></td></tr><tr><td><p><span class="RktErr">FAILURE</span></p></td></tr><tr><td><p><span class="RktErr">name: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">check-equal?</span></p></td></tr><tr><td><p><span class="RktErr">location: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">eval:67:0</span></p></td></tr><tr><td><p><span class="RktErr">actual: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">1</span></p></td></tr><tr><td><p><span class="RktErr">expected: </span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">2</span></p></td></tr><tr><td><p><span class="RktErr">--------------------</span></p></td></tr></table></td></tr></table></blockquote></blockquote></blockquote><p>Putting it all together, we can write the following code and save it
in a file called <span class="stt">bt.rkt</span>.  (You can right-click the file name and
save the code to try it out.)</p><p><div class="SIntrapara">This code follows a coding style that we will use in this course:
</div><div class="SIntrapara"><ul><li><p>it&rsquo;s organized in a module,</p></li><li><p>data type definitions occur at the top of the file,</p></li><li><p>it uses a test submodule to group unit tests,</p></li><li><p>tests occur immediately after the functions they test,</p></li><li><p>functions are annotated with type signatures and short purpose statements, and</p></li><li><p>indentation follows standard conventions (which DrRacket can apply for you).</p></li></ul></div></p><p>From the command line, you can run a module&rsquo;s tests using the Racket
command line testing tool <span class="stt">raco test</span>:</p><p><span class="stt">raco test bt.rkt</span></p><p>Or simply give a directory name and test everything within that directory:</p><p><span class="stt">raco test .</span></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Intro.html" title="backward to &quot;1 What is a Compiler?&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="a86.html" title="forward to &quot;3 a86: a Little Assembly Language&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>